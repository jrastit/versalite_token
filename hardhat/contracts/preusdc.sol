// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @title PreUSDC
 * @notice ERC‑20 style token representing a claim on future USDC deliveries.  The
 * contract holds an underlying asset (e.g., LINK) and allows the owner of
 * PreUSDC tokens to redeem them for USDC on a predefined destination chain via
 * LI.FI's diamond router.  Users can deposit their underlying tokens to mint
 * PreUSDC, withdraw the underlying back, or send USDC to a recipient on
 * another chain in a single transaction.  The cross‑chain swap and bridge
 * transaction is executed through the LI.FI diamond contract using
 * precomputed call data generated by the LI.FI API.
 */
contract PreUSDC {
    /// @dev Emitted when a user deposits underlying tokens and mints PreUSDC.
    event Deposited(address indexed account, uint256 amount);
    /// @dev Emitted when a user withdraws underlying tokens and burns PreUSDC.
    event Withdrawn(address indexed account, uint256 amount);
    /// @dev Emitted when a user initiates a cross‑chain USDC transfer.
    event SentUSDC(
        address indexed sender,
        address indexed recipient,
        uint256 preUsdcAmount,
        bytes32 liFiTxId
    );

    // -------------------------------------------------------------------------
    // ERC‑20 storage
    // -------------------------------------------------------------------------
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    // -------------------------------------------------------------------------
    // Underlying asset and LI.FI router configuration
    // -------------------------------------------------------------------------
    /// @notice ERC‑20 token used as the collateral for PreUSDC (e.g., LINK)
    IERC20 public immutable underlying;
    /// @notice Address of the LI.FI diamond contract used to execute swaps and bridges
    address public liFiDiamond;
    /// @notice Owner of the contract with permission to update configuration
    address public owner;

    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    /**
     * @param _underlying Address of the ERC‑20 token accepted as collateral
     * @param _liFiDiamond Address of the deployed LI.FI diamond contract
     * @param tokenName Name of the PreUSDC token
     * @param tokenSymbol Symbol of the PreUSDC token
     * @param tokenDecimals Decimals of the PreUSDC token (should match USDC, 6)
     */
    constructor(
        address _underlying,
        address _liFiDiamond,
        string memory tokenName,
        string memory tokenSymbol,
        uint8 tokenDecimals
    ) {
        require(_underlying != address(0), "Underlying token is zero address");
        require(_liFiDiamond != address(0), "LiFi diamond is zero address");
        underlying = IERC20(_underlying);
        liFiDiamond = _liFiDiamond;
        owner = msg.sender;
        _name = tokenName;
        _symbol = tokenSymbol;
        _decimals = tokenDecimals;
    }

    // -------------------------------------------------------------------------
    // Modifiers
    // -------------------------------------------------------------------------
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    // -------------------------------------------------------------------------
    // ERC‑20 view functions
    // -------------------------------------------------------------------------
    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function allowance(address owner_, address spender) external view returns (uint256) {
        return _allowances[owner_][spender];
    }

    // -------------------------------------------------------------------------
    // Internal ERC‑20 functions
    // -------------------------------------------------------------------------
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal {
        require(from != address(0), "Transfer from zero address");
        require(to != address(0), "Transfer to zero address");
        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "Transfer amount exceeds balance");
        unchecked {
            _balances[from] = fromBalance - amount;
            _balances[to] += amount;
        }
        emit Transfer(from, to, amount);
    }

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "Mint to zero address");
        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "Burn from zero address");
        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "Burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
            _totalSupply -= amount;
        }
        emit Transfer(account, address(0), amount);
    }

    function _approve(
        address owner_,
        address spender,
        uint256 amount
    ) internal {
        require(owner_ != address(0), "Approve from zero address");
        require(spender != address(0), "Approve to zero address");
        _allowances[owner_][spender] = amount;
        emit Approval(owner_, spender, amount);
    }

    // -------------------------------------------------------------------------
    // ERC‑20 public functions
    // -------------------------------------------------------------------------
    function transfer(address to, uint256 amount) external returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool) {
        uint256 currentAllowance = _allowances[from][msg.sender];
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
        unchecked {
            _approve(from, msg.sender, currentAllowance - amount);
        }
        _transfer(from, to, amount);
        return true;
    }

    // -------------------------------------------------------------------------
    // Deposit and withdrawal
    // -------------------------------------------------------------------------
    /**
     * @notice Deposit underlying tokens and mint PreUSDC.
     * @param amount Amount of underlying tokens to deposit.
     *
     * Requirements:
     * - `amount` must be greater than zero.
     * - Caller must have approved this contract to spend at least `amount` of the underlying token.
     */
    function deposit(uint256 amount) external {
        require(amount > 0, "Deposit amount is zero");
        // Transfer underlying tokens from user to contract
        bool ok = underlying.transferFrom(msg.sender, address(this), amount);
        require(ok, "Underlying transfer failed");
        // Mint PreUSDC at 1:1 ratio.  In production, use a price oracle to determine the correct mint amount.
        _mint(msg.sender, amount);
        emit Deposited(msg.sender, amount);
    }

    /**
     * @notice Withdraw underlying tokens by burning PreUSDC.
     * @param amount Amount of PreUSDC to burn and underlying to withdraw.
     */
    function withdraw(uint256 amount) external {
        require(amount > 0, "Withdraw amount is zero");
        _burn(msg.sender, amount);
        bool ok = underlying.transfer(msg.sender, amount);
        require(ok, "Underlying transfer failed");
        emit Withdrawn(msg.sender, amount);
    }

    // -------------------------------------------------------------------------
    // Cross‑chain send
    // -------------------------------------------------------------------------
    /**
     * @notice Send USDC on a destination chain to a recipient.  Burns
     * `preUsdcAmount` PreUSDC from the caller and calls the LI.FI diamond
     * contract to perform the swap and bridge using the provided call data.
     *
     * @param recipient Address of the recipient on the destination chain.  This
     * value may be ignored in the LI.FI call data if it is already encoded.
     * @param preUsdcAmount Amount of PreUSDC to burn.  In this example, we assume
     * a 1:1 ratio between PreUSDC and the underlying tokens.
     * @param liFiTxId A unique transaction identifier used for tracking.  The caller
     * should generate this off‑chain (e.g., UUID) to correlate events.
     * @param callData Encoded function call for the LI.FI diamond contract.  This
     * should be produced by the LI.FI API and specifies the swap + bridge route for
     * converting the underlying token into USDC on the destination chain.
     *
     * Requirements:
     * - Caller must have at least `preUsdcAmount` PreUSDC.
     * - `callData` must be valid for the LI.FI diamond contract.
     * - The contract must hold at least the required underlying tokens.  In production,
     *   amount translation and slippage protections should be implemented.
     */
    function sendUSDC(
        address recipient,
        uint256 preUsdcAmount,
        bytes32 liFiTxId,
        bytes calldata callData
    ) external payable {
        require(preUsdcAmount > 0, "Amount is zero");
        require(_balances[msg.sender] >= preUsdcAmount, "Insufficient PreUSDC balance");

        // Burn the PreUSDC to represent consumption of collateral
        _burn(msg.sender, preUsdcAmount);

        // Approve the LI.FI diamond to spend the underlying tokens.
        // In this simplistic example we assume 1 PreUSDC = 1 underlying token.
        underlying.approve(liFiDiamond, preUsdcAmount);

        // Call the LI.FI diamond with the provided calldata.  We forward any ETH sent by the caller.
        (bool success, bytes memory data) = liFiDiamond.call{ value: msg.value }(callData);
        require(success, "LI.FI call failed");

        // Emit event for off‑chain tracking
        emit SentUSDC(msg.sender, recipient, preUsdcAmount, liFiTxId);
        data; // silence compiler warning about unused variable
    }

    /**
     * @notice Single‑step send that pulls underlying tokens from the caller and
     * sends USDC on the destination chain without the user first minting PreUSDC.
     *
     * @param underlyingAmount Amount of underlying tokens (e.g., LINK) to transfer
     * from the caller for the swap/bridge.
     * @param liFiTxId Unique transaction ID for tracking.
     * @param callData Encoded function call for the LI.FI diamond contract.
     */
    function sendUSDCWithUnderlying(
        uint256 underlyingAmount,
        bytes32 liFiTxId,
        bytes calldata callData
    ) external payable {
        require(underlyingAmount > 0, "Amount is zero");
        // Pull the underlying tokens from the sender.  The user must approve this contract to spend at least `underlyingAmount`.
        bool ok = underlying.transferFrom(msg.sender, address(this), underlyingAmount);
        require(ok, "Underlying transfer failed");
        // Approve the LI.FI diamond to spend the tokens
        underlying.approve(liFiDiamond, underlyingAmount);
        // Call LI.FI diamond router
        (bool success, bytes memory data) = liFiDiamond.call{ value: msg.value }(callData);
        require(success, "LI.FI call failed");
        // Emit event.  In this case preUsdcAmount equals underlyingAmount since there is no intermediate PreUSDC mint.
        emit SentUSDC(msg.sender, address(0), underlyingAmount, liFiTxId);
        data;
    }

    // -------------------------------------------------------------------------
    // Owner functions
    // -------------------------------------------------------------------------
    /**
     * @notice Transfer ownership of the contract to a new address.
     * @param newOwner Address of the new owner.
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "New owner is zero address");
        owner = newOwner;
    }

    /**
     * @notice Update the address of the LI.FI diamond contract.  Can only be
     * called by the owner.  Use this to switch to a new router deployment.
     * @param newDiamond Address of the new LI.FI diamond contract.
     */
    function updateLiFiDiamond(address newDiamond) external onlyOwner {
        require(newDiamond != address(0), "New diamond is zero address");
        liFiDiamond = newDiamond;
    }

    // -------------------------------------------------------------------------
    // ERC‑20 events
    // -------------------------------------------------------------------------
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// -----------------------------------------------------------------------------
// IERC20 interface from OpenZeppelin (minimal)
// -----------------------------------------------------------------------------
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}